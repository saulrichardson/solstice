"""PyMuPDF-based text extraction implementation."""

import logging
from pathlib import Path
from typing import Tuple
import fitz  # PyMuPDF
from PIL import Image
from io import BytesIO

from .base_extractor import TextExtractor, ExtractorResult
from ..text_processing import process_text

logger = logging.getLogger(__name__)


class PyMuPDFExtractor(TextExtractor):
    """Text extraction using PyMuPDF library."""
    
    def extract_text_from_bbox(
        self,
        pdf_path: Path,
        page_num: int,
        bbox: Tuple[float, float, float, float],
        page_height: float
    ) -> ExtractorResult:
        """Extract text from PDF at specific bbox coordinates using PyMuPDF.
        
        Args:
            pdf_path: Path to PDF file
            page_num: 0-based page number
            bbox: Bounding box (x1, y1, x2, y2) in image coordinates
            page_height: Height of the page in image coordinates for conversion
            
        Returns:
            ExtractorResult containing extracted text
        """
        doc = fitz.open(pdf_path)
        page = doc[page_num]
        
        # Convert image coordinates to PDF coordinates
        # Image coordinates: origin at top-left, y increases downward
        # PDF coordinates: origin at bottom-left, y increases upward
        pdf_height = page.rect.height
        scale_factor = pdf_height / page_height
        
        # Convert and scale coordinates
        x1 = bbox[0] * scale_factor
        x2 = bbox[2] * scale_factor
        
        # Flip Y coordinates and scale
        y1 = pdf_height - (bbox[3] * scale_factor)  # bbox[3] is bottom in image coords
        y2 = pdf_height - (bbox[1] * scale_factor)  # bbox[1] is top in image coords
        
        # Create rect in PDF coordinate system
        rect = fitz.Rect(x1, y1, x2, y2)
        
        # Extract text from the rectangle
        text = page.get_text("text", clip=rect)
        
        doc.close()
        
        # Clean up extracted text
        text = text.strip()
        
        # Process text through text processing functions
        processed_text = process_text(text)
        
        # Build metadata
        metadata = {
            "method": "pymupdf",
            "scale_factor": scale_factor
        }
        
        return ExtractorResult(
            text=processed_text,
            confidence=1.0,  # PyMuPDF doesn't provide confidence scores
            metadata=metadata
        )
    
    def extract_figure_image(
        self,
        pdf_path: Path,
        page_num: int,
        bbox: Tuple[float, float, float, float],
        dpi: int = 300
    ) -> Image.Image:
        """Extract figure/table as image from PDF using PyMuPDF.
        
        Args:
            pdf_path: Path to PDF file
            page_num: 0-based page number
            bbox: Bounding box (x1, y1, x2, y2) in image coordinates
            dpi: DPI for rendering
            
        Returns:
            PIL Image of the cropped region
        """
        doc = fitz.open(pdf_path)
        page = doc[page_num]
        
        # Render page at specified DPI
        mat = fitz.Matrix(dpi/72.0, dpi/72.0)
        pix = page.get_pixmap(matrix=mat)
        
        # Convert to PIL Image
        img_data = pix.tobytes("png")
        doc.close()
        
        # Open as PIL Image and crop
        full_page = Image.open(BytesIO(img_data))
        
        # ------------------------------------------------------------------
        # Bounding-box coordinates are generated by the layout-detection
        # stage on images that were rasterised at *detection_dpi*.
        # Down-stream we pass the very same `dpi` value that has been used
        # for detection when we call this helper, therefore the bbox lives
        # in the *same* pixel coordinate space as the rendered bitmap that
        # we have just obtained from PyMuPDF.  Any additional scaling would
        # therefore introduce a systematic offset and size error â€“ exactly
        # what we observed when the detection ran at 400 DPI or 600 DPI: the
        # cropped region was shifted and did not match the overlay drawn in
        # the debug visualisations.
        #
        # In short: **do not scale**; use the bbox as-is.
        # ------------------------------------------------------------------

        cropped = full_page.crop(
            (
                int(bbox[0]),
                int(bbox[1]),
                int(bbox[2]),
                int(bbox[3]),
            )
        )
        
        return cropped
